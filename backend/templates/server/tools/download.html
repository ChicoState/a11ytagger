<div style="display: flex; flex-direction: column; gap: 0.75rem; padding: 0.5rem 0;">
    <a id="download-pdf-btn" href="/api/{{ pdf_id }}/download/" download style="
        display: block;
        width: 100%;
        padding: 0.75rem;
        background: #10b981;
        color: white;
        border: none;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        text-align: center;
        text-decoration: none;
        transition: background 0.2s;
    ">
        Download PDF
    </a>
    
    <button id="exit-viewer-btn" style="
        width: 100%;
        padding: 0.75rem;
        background: #ef4444;
        color: white;
        border: none;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        font-weight: 500;
        cursor: pointer;
        transition: background 0.2s;
    ">
        Exit & Clean Up
    </button>
    
    <div id="download-status" style="
        padding: 0.5rem;
        border-radius: 0.25rem;
        font-size: 0.875rem;
        display: none;
    "></div>
</div>

<style>
    #download-pdf-btn:hover {
        background: #059669;
    }
    
    #exit-viewer-btn:hover {
        background: #dc2626;
    }
    
    .download-status-success {
        background: #d1fae5;
        color: #065f46;
    }
    
    .download-status-error {
        background: #fee2e2;
        color: #991b1b;
    }
    
    .download-status-info {
        background: #dbeafe;
        color: #1e40af;
    }
</style>

<script>
    (function() {
        const pdfId = '{{ pdf_id }}';
        const exitBtn = document.getElementById('exit-viewer-btn');
        const statusDiv = document.getElementById('download-status');
        
        function showStatus(message, type = 'info') {
            statusDiv.textContent = message;
            statusDiv.className = `download-status-${type}`;
            statusDiv.style.display = 'block';
            
            if (type !== 'error') {
                setTimeout(() => {
                    statusDiv.style.display = 'none';
                }, 3000);
            }
        }
        
        exitBtn.addEventListener('click', async () => {
            if (!confirm('Are you sure you want to exit? This will clean up temporary files.')) {
                return;
            }
            
            try {
                showStatus('Cleaning up...', 'info');
                
                const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]')?.value || 
                                  document.cookie.match(/csrftoken=([^;]+)/)?.[1];
                
                const response = await fetch(`/api/${pdfId}/cleanup/`, {
                    method: 'POST',
                    headers: {
                        'X-CSRFToken': csrfToken,
                    }
                });
                
                if (!response.ok) {
                    throw new Error('Failed to clean up');
                }
                
                showStatus('Cleanup complete. Redirecting...', 'success');
                
                setTimeout(() => {
                    window.location.href = '/';
                }, 1000);
                
            } catch (error) {
                console.error('Cleanup error:', error);
                showStatus('Error during cleanup: ' + error.message, 'error');
            }
        });
    })();
</script>
